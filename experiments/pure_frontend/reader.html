<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDF Reader with pdf.js + Browser TTS / MiniMax TTS</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 0; padding: 1rem; background: #f4f4f4; }
    .app { max-width: 1000px; margin: 0 auto; background: #fff; border-radius: 12px; padding: 1rem 1.5rem 1.5rem; box-shadow: 0 4px 14px rgba(0,0,0,.08); }
    h1 { margin: .25rem 0 0; font-size: 1.35rem; }

    #toolbar { display: grid; grid-template-columns: 1fr; gap: .75rem; margin: .75rem 0; }
    .row { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; }
    .row label { font-size: .9rem; color: #444; }

    button { padding: .45rem .9rem; border-radius: 8px; border: 1px solid #ccc; background: #f7f7f7; cursor: pointer; font-size: .9rem; }
    button:disabled { opacity: .5; cursor: default; }
    select, input[type="text"], input[type="password"], input[type="number"] { padding: .4rem .55rem; border-radius: 8px; border: 1px solid #ccc; font-size: .9rem; }
    input[type="range"] { width: 160px; }

    #pdf-container { position: relative; display: inline-block; max-width: 100%; }
    #pdf-canvas { border: 1px solid #ddd; border-radius: 6px; width: 100%; background: #fafafa; display: block; }

    #text-layer { position: absolute; left: 0; top: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; }
    .text-span { position: absolute; white-space: pre; pointer-events: auto; cursor: pointer; color: transparent; }
    .text-span.highlight-hover { background: rgba(255,255,0,.4); }

    #page-info { margin-left: auto; font-size: .9rem; }
    #status { margin-top: .5rem; font-size: .9rem; color: #555; }
    .divider { height: 1px; background: #eee; margin: .5rem 0; }
  </style>
  <!-- pdf.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>
<body>
  <div class="app">
    <h1>PDF Viewer + TTS (Hover/Click segments, Read page)</h1>

    <div id="toolbar">
      <div class="row">
        <input id="file-input" type="file" accept="application/pdf" />
        <button id="prev-page" disabled>‚óÄ Prev page</button>
        <button id="next-page" disabled>Next page ‚ñ∂</button>
        <button id="read-page" disabled>üîä Read current page</button>
        <button id="pause-tts" disabled>‚è∏ Pause</button>
        <button id="resume-tts" disabled>‚ñ∂ Resume</button>
        <button id="stop-tts" disabled>‚èπ Stop</button>
        <span id="page-info">No PDF loaded</span>
      </div>

      <div class="divider"></div>

      <div class="row">
        <label for="tts-engine"><strong>TTS Engine</strong></label>
        <select id="tts-engine">
          <option value="browser">Browser (SpeechSynthesis)</option>
          <option value="minimax">MiniMax (HTTP API)</option>
        </select>
        <span id="engine-hint" style="font-size:.85rem;color:#666">Browser: No need for InternetÔºõMiniMaxÔºörequire API KeyÔºåmore natural sound</span>
      </div>

      <div id="minimax-panel" style="display:none">
        <div class="row">
          <label for="minimax-key">MiniMax API Key</label>
          <input id="minimax-key" type="password" placeholder="local test" style="min-width:340px" />
          <label>Remember pwd</label>
          <input id="remember-key" type="checkbox" />
        </div>
        <div class="row">
          <label for="minimax-voice">Voice</label>
          <select id="minimax-voice"></select>
          <input id="minimax-voice-custom" type="text" placeholder="Custom voice_id" style="display:none; min-width:260px" />
          <label for="minimax-speed">Speed</label>
          <input id="minimax-speed" type="range" min="0.5" max="2" step="0.1" value="1" />
          <span id="speed-val" style="min-width:2.5rem">1.0</span>
          <label for="minimax-sr">Sample Rate</label>
          <select id="minimax-sr">
            <option value="32000" selected>32000</option>
            <option value="24000">24000</option>
            <option value="16000">16000</option>
          </select>
          <label for="minimax-format">Format</label>
          <select id="minimax-format">
            <option value="mp3" selected>mp3</option>
            <option value="wav">wav</option>
          </select>
        </div>
      </div>
    </div>

    <!-- Canvas + text layer overlay -->
    <div id="pdf-container">
      <canvas id="pdf-canvas"></canvas>
      <div id="text-layer"></div>
    </div>

    <div id="status">Choose a PDF file to begin.</div>

    <!-- Unified audio element for MiniMax playback -->
    <audio id="player" hidden></audio>
  </div>

  <script>
    // ------------------------- pdf.js setup -------------------------
    const pdfjsLib = window['pdfjsLib'];
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    const fileInput = document.getElementById('file-input');
    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');
    const prevBtn = document.getElementById('prev-page');
    const nextBtn = document.getElementById('next-page');
    const readBtn = document.getElementById('read-page');
    const pauseBtn = document.getElementById('pause-tts');
    const resumeBtn = document.getElementById('resume-tts');
    const stopBtn = document.getElementById('stop-tts');
    const pageInfo = document.getElementById('page-info');
    const statusEl = document.getElementById('status');
    const textLayerEl = document.getElementById('text-layer');

    const engineSel = document.getElementById('tts-engine');
    const minimaxPanel = document.getElementById('minimax-panel');
    const audioEl = document.getElementById('player');

    const keyInput = document.getElementById('minimax-key');
    const rememberKey = document.getElementById('remember-key');
    const voiceSel = document.getElementById('minimax-voice');
    const voiceCustom = document.getElementById('minimax-voice-custom');
    const speedSlider = document.getElementById('minimax-speed');
    const speedVal = document.getElementById('speed-val');
    const srSel = document.getElementById('minimax-sr');
    const fmtSel = document.getElementById('minimax-format');

    let pdfDoc = null;
    let currentPage = 1;
    const scale = 1.3;

    // ------------------------- Browser TTS helpers -------------------------
    let currentUtterance = null;

    function supportsTTS() {
      return 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window;
    }

    function setStatus(message) { statusEl.textContent = message; }

    function resetTTS() {
      // Stop browser TTS
      if (supportsTTS()) {
        window.speechSynthesis.cancel();
      }
      currentUtterance = null;
      // Stop MiniMax audio
      audioEl.pause();
      audioEl.currentTime = 0;

      pauseBtn.disabled = true;
      resumeBtn.disabled = true;
      stopBtn.disabled = true;
    }

    function speakWithBrowserTTS(text) {
      if (!supportsTTS()) { alert('Your browser does not support Speech Synthesis API.'); return; }
      window.speechSynthesis.cancel();
      const utter = new SpeechSynthesisUtterance(text);
      currentUtterance = utter;

      pauseBtn.disabled = false; stopBtn.disabled = false; resumeBtn.disabled = true;
      utter.onstart = () => setStatus('Reading (Browser TTS)...');
      utter.onend = () => { setStatus('Finished.'); pauseBtn.disabled = true; resumeBtn.disabled = true; stopBtn.disabled = true; };
      utter.onerror = (e) => { console.error('TTS error', e); setStatus('Error during speech synthesis.'); pauseBtn.disabled = true; resumeBtn.disabled = true; stopBtn.disabled = true; };
      window.speechSynthesis.speak(utter);
    }

    // ------------------------- MiniMax HTTP TTS -------------------------
    const MINI_VOICES = [
      { id: 'English_expressive_narrator', label: 'English ‚Äî Expressive Narrator' },
      { id: 'English_male_calm', label: 'English ‚Äî Male Calm' },
      { id: 'English_female_soft', label: 'English ‚Äî Female Soft' },
      { id: 'English_male_energetic', label: 'English ‚Äî Male Energetic' },
      { id: 'English_Graceful_Lady', label: 'English ‚Äî Graceful Lady' },
      { id: 'English_Insightful_Speaker', label: 'English ‚Äî Insightful Speaker' },
      { id: 'Chinese (Mandarin)_Lyrical_Voice', label: '‰∏≠Êñá ‚Äî ÊäíÊÉÖ' },
      { id: 'Chinese (Mandarin)_HK_Flight_Attendant', label: '‰∏≠Êñá ‚Äî Ê∏ØÂºèÁ©∫‰πò' },
      { id: 'moss_audio_ce44fc67-7ce3-11f0-8de5-96e35d26fb85', label: '‰∏≠Êñá ‚Äî MOSS 1' },
      { id: 'moss_audio_aaa1346a-7ce7-11f0-8e61-2e6e3c7ee85d', label: '‰∏≠Êñá ‚Äî MOSS 2' },
      { id: 'Japanese_Whisper_Belle', label: 'Êó•Êú¨Ë™û ‚Äî Whisper Belle' },
      { id: '__custom__', label: 'Custom‚Ä¶' }
    ];

    function populateMiniVoices() {
      voiceSel.innerHTML = '';
      MINI_VOICES.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v.id; opt.textContent = v.label; voiceSel.appendChild(opt);
      });
      voiceSel.value = 'English_expressive_narrator';
      toggleCustomVoice();
    }

    function toggleCustomVoice() {
      const useCustom = voiceSel.value === '__custom__';
      voiceCustom.style.display = useCustom ? 'inline-block' : 'none';
      voiceCustom.disabled = !useCustom;
    }

    function getSelectedVoiceId() {
      return (voiceSel.value === '__custom__') ? (voiceCustom.value || '').trim() : voiceSel.value;
    }

    function hexToBytes(hex) {
      const len = hex.length; const buf = new Uint8Array(len / 2);
      for (let i = 0; i < len; i += 2) buf[i/2] = parseInt(hex.substr(i, 2), 16);
      return buf;
    }

    async function callMinimaxTTS({ apiKey, text, voiceId, speed=1.0, sampleRate=32000, format='mp3', channel=1 }) {
      const url = 'https://api.minimax.io/v1/t2a_v2';
      const body = {
        model: 'speech-2.6-hd',
        text,
        stream: false,
        output_format: 'hex',
        language_boost: 'auto',
        voice_setting: { voice_id: voiceId, speed: speed, vol: 1.0, pitch: 0 },
        audio_setting: { sample_rate: sampleRate, bitrate: 128000, format: format, channel: channel }
      };
      const resp = await fetch(url, {
        method: 'POST',
        headers: { 'Authorization': 'Bearer ' + apiKey, 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });
      if (!resp.ok) { throw new Error('HTTP ' + resp.status + ' ' + await resp.text()); }
      const result = await resp.json();
      if ((result.base_resp?.status_code ?? -1) !== 0) {
        throw new Error('API: ' + (result.base_resp?.status_msg || 'unknown error'));
      }
      const hex = result.data?.audio; if (!hex) throw new Error('empty audio');
      const mime = (format === 'wav') ? 'audio/wav' : 'audio/mpeg';
      return new Blob([hexToBytes(hex)], { type: mime });
    }

    async function speakWithMiniMax(text) {
      const apiKey = keyInput.value.trim();
      const voiceId = getSelectedVoiceId();
      const speed = parseFloat(speedSlider.value || '1');
      const sampleRate = parseInt(srSel.value, 10) || 32000;
      const format = fmtSel.value || 'mp3';
      if (!apiKey) { alert('Please enter MiniMax API Key'); return; }
      if (!voiceId) { alert('Please select voice_id'); return; }
      setStatus('Calling MiniMax TTS‚Ä¶');
      const started = Date.now();
      try {
        const blob = await callMinimaxTTS({ apiKey, text, voiceId, speed, sampleRate, format, channel: 1 });
        resetTTS();
        const url = URL.createObjectURL(blob);
        audioEl.src = url; audioEl.hidden = false;
        await audioEl.play();
        setStatus('Playing (MiniMax)‚Ä¶ ' + ((Date.now()-started)/1000).toFixed(2) + 's');
        pauseBtn.disabled = false; stopBtn.disabled = false; resumeBtn.disabled = true;
      } catch (e) {
        console.error(e);
        setStatus('MiniMax TTS failsÔºö' + (e.message || ''));
      }
    }

    function speakUnified(text) {
      if (engineSel.value === 'minimax') {
        speakWithMiniMax(text);
      } else {
        speakWithBrowserTTS(text);
      }
    }

    // ------------------------- Text extraction & rendering -------------------------
    function getPageText(pageNumber) {
      return pdfDoc.getPage(pageNumber).then((page) => {
        return page.getTextContent().then((textContent) => {
          const strings = textContent.items.map((item) => item.str);
          return strings.join(' ');
        });
      });
    }

    function renderTextLayer(page, viewport) {
      textLayerEl.innerHTML = '';
      return page.getTextContent().then((textContent) => {
        textContent.items.forEach((item) => {
          const text = item.str; if (!text.trim()) return;
          const span = document.createElement('span');
          span.textContent = text; span.className = 'text-span';
          const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
          const x = tx[4], y = tx[5], fontHeight = Math.abs(tx[3]);
          const cssTop = viewport.height - y;
          span.style.left = x + 'px';
          span.style.top = cssTop + 'px';
          span.style.fontSize = fontHeight + 'px';
          span.style.height = fontHeight + 'px';
          span.addEventListener('mouseenter', () => span.classList.add('highlight-hover'));
          span.addEventListener('mouseleave', () => span.classList.remove('highlight-hover'));
          span.addEventListener('click', (ev) => { ev.stopPropagation(); resetTTS(); speakUnified(text); });
          textLayerEl.appendChild(span);
        });
      });
    }

    function renderPage(num) {
      pdfDoc.getPage(num).then((page) => {
        const viewport = page.getViewport({ scale });
        canvas.height = viewport.height; canvas.width = viewport.width;
        textLayerEl.style.width = canvas.width + 'px'; textLayerEl.style.height = canvas.height + 'px';
        const renderContext = { canvasContext: ctx, viewport };
        setStatus('Rendering page ' + num + '...');
        page.render(renderContext).promise.then(() => setStatus('Page ' + num + ' of ' + pdfDoc.numPages));
        renderTextLayer(page, viewport);
        pageInfo.textContent = `Page ${num} / ${pdfDoc.numPages}`;
        prevBtn.disabled = (num <= 1); nextBtn.disabled = (num >= pdfDoc.numPages); readBtn.disabled = false;
      });
    }

    // ------------------------- Events -------------------------
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0]; if (!file) return;
      const reader = new FileReader();
      reader.onload = function(ev) {
        const typedarray = new Uint8Array(ev.target.result);
        setStatus('Loading PDF...');
        pdfjsLib.getDocument({ data: typedarray }).promise.then((pdf) => {
          pdfDoc = pdf; currentPage = 1; setStatus('PDF loaded. Rendering first page...');
          renderPage(currentPage); readBtn.disabled = false;
        }).catch((err) => { console.error(err); setStatus('Error loading PDF: ' + err.message); });
      };
      reader.readAsArrayBuffer(file);
    });

    prevBtn.addEventListener('click', () => { if (currentPage <= 1) return; currentPage--; resetTTS(); renderPage(currentPage); });
    nextBtn.addEventListener('click', () => { if (currentPage >= pdfDoc.numPages) return; currentPage++; resetTTS(); renderPage(currentPage); });

    readBtn.addEventListener('click', () => {
      if (!pdfDoc) return; resetTTS(); setStatus('Extracting text from page ' + currentPage + '...');
      getPageText(currentPage).then((text) => {
        if (!text.trim()) { setStatus('No readable text found on this page.'); return; }
        speakUnified(text);
      }).catch((err) => { console.error(err); setStatus('Error extracting text.'); });
    });

    pauseBtn.addEventListener('click', () => {
      if (engineSel.value === 'minimax') {
        if (!audioEl.paused) { audioEl.pause(); setStatus('Paused (MiniMax).'); resumeBtn.disabled = false; pauseBtn.disabled = true; }
      } else if (supportsTTS()) {
        if (window.speechSynthesis.speaking && !window.speechSynthesis.paused) {
          window.speechSynthesis.pause(); setStatus('Paused.'); resumeBtn.disabled = false; pauseBtn.disabled = true;
        }
      }
    });

    resumeBtn.addEventListener('click', async () => {
      if (engineSel.value === 'minimax') {
        await audioEl.play(); setStatus('Resumed (MiniMax).'); resumeBtn.disabled = true; pauseBtn.disabled = false;
      } else if (supportsTTS()) {
        if (window.speechSynthesis.paused) { window.speechSynthesis.resume(); setStatus('Resumed.'); resumeBtn.disabled = true; pauseBtn.disabled = false; }
      }
    });

    stopBtn.addEventListener('click', () => {
      if (engineSel.value === 'minimax') {
        audioEl.pause(); audioEl.currentTime = 0; setStatus('Stopped.');
      } else if (supportsTTS()) {
        window.speechSynthesis.cancel(); setStatus('Stopped.');
      }
      pauseBtn.disabled = true; resumeBtn.disabled = true; stopBtn.disabled = true;
    });

    // Engine toggle & settings
    engineSel.addEventListener('change', () => {
      const useMini = engineSel.value === 'minimax';
      minimaxPanel.style.display = useMini ? 'block' : 'none';
      if (!useMini) { audioEl.hidden = true; }
      resetTTS();
    });

    voiceSel.addEventListener('change', toggleCustomVoice);
    speedSlider.addEventListener('input', () => { speedVal.textContent = parseFloat(speedSlider.value).toFixed(1); });

    rememberKey.addEventListener('change', () => {
      if (rememberKey.checked) {
        localStorage.setItem('minimax_key', keyInput.value);
      } else {
        localStorage.removeItem('minimax_key');
      }
    });

    keyInput.addEventListener('input', () => {
      if (rememberKey.checked) localStorage.setItem('minimax_key', keyInput.value);
    });

    // Init
    (function init() {
      populateMiniVoices();
      // restore key if saved
      const savedKey = localStorage.getItem('minimax_key');
      if (savedKey) { keyInput.value = savedKey; rememberKey.checked = true; }
      if (!supportsTTS()) {
        setStatus('Warning: this browser does not support the Web Speech (TTS) API. You can switch to MiniMax.');
      }
    })();
  </script>
</body>
</html>
